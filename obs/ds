#!/usr/bin/python
from __future__ import division
import ROOT

from proc_yields import ProcYields
from disp_yields import DispYields

import atlib as atlib
import q2w_bng

import collections
from array import *
import os,sys
import glob

import matplotlib.pyplot as plt
import numpy as np



"""
This script displays simstats for user entered sim (siml by default):
	+ nevts-T,R,H(Q2,W)
	+ nbins-T,R,H(Q2,W)
The display is saved in $OBS_DIR/sim

Issues while running this script:
+ [08-14-15]: Variable binning in TH2F is causing core dumps when tryign to draw histograms post
division operation (This seems to not be an issue when using CINT)
"""

#! User input sim, else use siml
if len(sys.argv)<2:
	sim='siml'
else:
	sim=sys.argv[1]
print "Displaying simstats for %s"%sim

datadir=os.environ['OBS_DATADIR_SIM']
outdir=os.path.join(os.environ['OBS_DIR'],sim,'simstats')
if not os.path.exists(outdir):
	os.makedirs(outdir)

q2wl=['q2w%i'%i for i in range(1,50)]
#! Remove "bad" bins (cases where there is no data in yields_exp.root)
q2wl_bad=['q2w7','q2w14','q2w20','q2w21','q2w27','q2w28','q2w29','q2w34','q2w35','q2w36','q2w40','q2w41','q2w42','q2w43','q2w46','q2w47','q2w48','q2w49']
q2wl=[x for x in q2wl if x not in q2wl_bad]
#! q2wl for debugging
#q2wl=['q2w1','q2w2']

#! + The following binning should match up with q2w_bng.h/.py
#! + It is slightly modified here for "aesthetic" purposes
wbins,wmin,wmax=80,1.0,3.0 #25 MeV/bin
q2bins,q2min,q2max=7,1.2,5.0 # place-holder bng, for it will be modified by variable bng
q2_varbins=array("d",[1.0,1.2,1.6,2.0,2.4,3.0,3.5,4.2,5.0])
h={}
for seq in ['T','R','A','H']:
	for par in ['nbins','N','mu','sg']:
		h[seq,par]=ROOT.TH2F("h_%s_%s"%(par,seq),"%s_%s(Q2,W)"%(par,seq),wbins,wmin,wmax,q2bins,q2min,q2max)
		h[seq,par].GetYaxis().Set(len(q2_varbins)-1,q2_varbins)
		h[seq,par].SetXTitle("W [GeV]")
		h[seq,par].SetYTitle("Q^2 [GeV^2]")
		print("bins for h(%s,%s)=%d,%d"%(seq,par,h[seq,par].GetXaxis().GetNbins(),
			h[seq,par].GetYaxis().GetNbins()))
		#! Fix z-scale for h[seq,'nbins'] as per maximum number of PS bins(VST1)
		if par=='nbins':
			h[seq,par].GetZaxis().SetRangeUser(0,5000000)
		# #! Fix z-scale for h['T','mu']
		# if seq=='T' and par=='mu':
		# 	h[seq,par].GetZaxis().SetRangeUser(0,150)
		# #! Fix z-scale for h['R','mu']
		# if seq=='R' and par=='mu':
		# 	h[seq,par].GetZaxis().SetRangeUser(0,15)
		#! Fix z-scale for h['A','mu']
		if seq=='A' and par=='mu':
			h[seq,par].GetZaxis().SetRangeUser(0,0.5)
#! Some histograms that I could have obtain using TH2F::Divide(), but due to to bug
#! noted, have to create these and fill them manually
#! 1. h_A_relerr
h_A_relerr=ROOT.TH2F("h_relerr_A","mu_A/sg_A(Q2,W)",wbins,wmin,wmax,q2bins,q2min,q2max)
h_A_relerr.GetYaxis().Set(len(q2_varbins)-1,q2_varbins)
h_A_relerr.SetXTitle("W [GeV]")
h_A_relerr.SetYTitle("Q^2 [GeV^2]")
print("bins for h_A_relerr=%d,%d"%(h_A_relerr.GetXaxis().GetNbins(),
	h_A_relerr.GetYaxis().GetNbins()))
#! Fix z-scale for h_A_relerr
h_A_relerr.GetZaxis().SetRangeUser(0,1)
#! 2. h_fracH
# h_fracH=ROOT.TH2F("h_fracH","h_fracH(Q2,W)",wbins,wmin,wmax,q2bins,q2min,q2max)
# h_fracH.GetYaxis().Set(len(q2_varbins)-1,q2_varbins)
# h_fracH.SetXTitle("W [GeV]")
# h_fracH.SetYTitle("Q^2 [GeV^2]")
# print("bins for h_fracH=%d,%d"%(h_fracH.GetXaxis().GetNbins(),
# 	h_fracH.GetYaxis().GetNbins()))

	# h[seq,par]=ROOT.TH2F("h_nevts%s"%seq,"nevts%s(Q2,W)"%seq,wbins,wmin,wmax,q2bins,q2min,q2max)
	# h[seq,par].GetYaxis().Set(len(q2_varbins)-1,q2_varbins)
	# h[seq,par].SetXTitle("W [GeV]")
	# h[seq,par].SetYTitle("Q^2 [GeV^2]")
	# print("bins for h(%s,nevts=%d,%d)"%(seq,h[seq,par].GetXaxis().GetNbins(),
	# 	h[seq,par].GetYaxis().GetNbins()))

	# h[seq,'nbins']=ROOT.TH2F("h_nbins%s"%seq,"nbins%s(Q2,W)"%seq,wbins,wmin,wmax,q2bins,q2min,q2max)
	# h[seq,'nbins'].GetYaxis().Set(len(q2_varbins)-1,q2_varbins)
	# h[seq,'nbins'].SetXTitle("W [GeV]")
	# h[seq,'nbins'].SetYTitle("Q^2 [GeV^2]")
	# print("bins for h(%s,nbins=%d,%d)"%(seq,h[seq,'nbins'].GetXaxis().GetNbins(),
	# 	h[seq,'nbins'].GetYaxis().GetNbins()))

for q2w in q2wl: 
	dy=DispYields(q2w,sim)
	ss=dy.get_sim_stats()
	#nbins_T=0 #! This is needed workaround for filling h_fracH(due to PyROOT:TH2F(varbin):Divide() bug)
	for seq in ['T','R','A','H']:
		for d in ss[seq]:
			q2,w,nbins,N,mu,sg=d[0],d[1],d[2],d[3],d[4],d[5]
			binx=h[seq,'nbins'].GetXaxis().FindBin(w+(0.025/2));
			biny=h[seq,'nbins'].GetYaxis().FindBin(q2);
			bin=h[seq,'nbins'].GetBin(binx,biny)
			h[seq,'N'].SetBinContent(bin,nbins)
			h[seq,'nbins'].SetBinContent(bin,nbins)
			h[seq,'mu'].SetBinContent(bin,mu)
			h[seq,'sg'].SetBinContent(bin,sg)
			#! Following has to be done due to PyROOT:TH2F(varbin):Divide() bug
			# if seq=='T':
			# 	nbins_T=nbins
			# 	print('seq=%s,q2=%f,w=%f,nbins=%d,nbins_T%d'%(seq,q2,w,nbins,nbins_T))
			# if seq=='H':
			# 	h_fracH.SetBinContent(bin,nbins/nbins_T)
			# 	print('seq=%s,q2=%f,w=%f,nbins=%d,nbins_T%d'%(seq,q2,w,nbins,nbins_T))
			if seq=='A':
				h_A_relerr.SetBinContent(bin,mu/sg)
			
	
ROOT.gStyle.SetOptStat(0)
c_pars=ROOT.TCanvas("cpars","cpars",2000,1500)
c_pars.Divide(4,3)
c_pars.cd(1)
h['T','N'].Draw("colz")
c_pars.cd(2)
h['R','N'].Draw("colz")
pad=c_pars.cd(3)
#pad.SetLogz()
h['T','nbins'].Draw("colz")
c_pars.cd(4)
h['H','nbins'].Divide(h['T','nbins'])
h['H','nbins'].GetZaxis().SetRangeUser(0,1)
h['H','nbins'].SetTitle('nbinsH/nbinsT(Q2,W)')
h['H','nbins'].Draw("colz")
#h_fracH.Draw("colz")
c_pars.cd(5)
h['T','mu'].Draw("colz")
c_pars.cd(6)
h['T','sg'].Draw("colz")
c_pars.cd(7)
h['R','mu'].Draw("colz")
c_pars.cd(8)
h['R','sg'].Draw("colz")
c_pars.cd(9)
h['A','mu'].Draw("colz")
c_pars.cd(10)
h_A_relerr.Draw("colz")
c_pars.SaveAs("%s/pars.png"%outdir)

# c_pars.Divide(2,3)
# pad=c_pars.cd(1)
# #pad.SetLogz()
# h['T','nbins'].Draw("colz")
# c_pars.cd(2)
# h['H','nbins'].Divide(h['T','nbins'])
# h['H','nbins'].GetZaxis().SetRangeUser(0,1)
# h['H','nbins'].SetTitle('nbinsH/nbinsT(Q2,W)')
# h['H','nbins'].Draw("colz")
# #h_fracH.Draw("colz")
# c_pars.cd(3)
# h['T','mu'].Draw("colz")
# c_pars.cd(4)
# h['R','mu'].Draw("colz")
# c_pars.cd(5)
# h['A','mu'].Draw("colz")
# c_pars.cd(6)
# h_A_relerr.Draw("colz")
# # h_A_relerr=h['A','mu'].Clone()
# # h_A_relerr.Divide(h['A','sg'])
# # h_A_relerr.SetName('h_A_relerr')
# # h_A_relerr.SetTitle('mu/sg_A(Q2,W)')
# c_pars.SaveAs("%s/pars.png"%outdir)

# c_nevts=ROOT.TCanvas("cnevts","cnevts",1000,1000)
# c_nevts.Divide(2,1)
# c_nevts.cd(1)
# h['T','N'].Draw("colz")
# c_nevts.cd(2)
# h['R','N'].Draw("colz")
# c_nevts.SaveAs("%s/nevts.png"%outdir)

# print("here")
# c_nbins=ROOT.TCanvas("cnbins","cnbins",1000,500)
# c_nbins.Divide(3,1)
# c_nbins.cd(1)
# h['T','nbins'].Draw("colz")
# print("here2")
# c_nbins.cd(2)
# h['R','nbins'].Draw("colz")
# print("here3")
# c_nbins.cd(3)

# hH=h['H','nbins'].Clone("hnew")
# print("here4")
# hH.Divide(h['T','nbins'])
# hH.SetName("fracH")
# hH.SetTitle("nbinsH/nbinsT(Q2,W)")
# print("here5")
# hH.Draw("colz")
# print("here6")

# # h['H','nbins'].Divide(h['T','nbins'])
# # h['H','nbins'].Draw("colz")

# c_nbins.SaveAs("%s/nbins.png"%outdir)
# print("here7")

# print("here\n")
# c_nevts_per_bin=ROOT.TCanvas("cnevts_per_bin","cnevts_per_bin",1000,500)
# c_nevts_per_bin.Divide(2,1)

# pad=c_nevts_per_bin.cd(1)
# hT=h['T',par].Clone()
# hT.Divide(h['T','nbins'])
# hT.SetName("T")
# hT.SetTitle("<nevts/bin>T")
# hT.Draw("colz")

# pad=c_nevts_per_bin.cd(2)
# hR=h['R',par].Clone()
# hR.Divide(h['R','nbins'])
# hR.SetName("R")
# hR.SetTitle("<nevts/bin>R")
# hR.Draw("colz")

# c_nevts_per_bin.cd(3)
# h['H',par].Divide(h['T',par])
# h['H',par].Draw("colz")

# c_nevts_per_bin.SaveAs("%s/test.png"%outdir)
# print("here9\n")

	
#! I was trying to using matplotlib's 3d plotting but abandoned it for TH2F

# fig = plt.figure()
# ax = fig.add_subplot(111, projection='3d')
# n = 100
# # for c, m, zl, zh in [('r', 'o', -50, -25), ('b', '^', -30, -5)]:
# #     xs = randrange(n, 23, 32)
# #     ys = randrange(n, 0, 100)
# #     zs = randrange(n, zl, zh)
# #     ax.scatter(xs, ys, zs, c=c, marker=m)
# c=cm.rainbow(np.linspace(0, 1, len(siml)))
# l,l_proxy=[],[]
# for isim,sim in enumerate(siml):
# 	l.append(ax.scatter(q2[sim],w[sim],nbins[sim],c=c[isim],marker='o',label=sim))
# 	l_proxy.append(matplotlib.lines.Line2D([0],[0], linestyle="none",c=c[isim],marker='o'))

# ax.legend(l_proxy,siml,prop={'size':9})

# ax.set_xlabel('Q2')
# ax.set_ylabel('W')
# ax.set_zlabel('nbins')

# plt.show()
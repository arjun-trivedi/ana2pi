#!/usr/bin/python
from __future__ import division

import os,sys,datetime,subprocess,time

from collections import OrderedDict

#! --  Additional options. For full details see h10looper_e1f.h -- 
#! + Default values on [12-14-15], in brackets, are toggled when any of the options are selected
# 1:  ECin (OFF)
# 2:  ECfid (OFF)
# 3:  zvtx (OFF)
# 4:  etot (ON)
# 5:  hitSC (ON) 
# 6:  dc_stat (ON)
# 7:  ep_efid ( ON, only for E1F)
# 8:  ep_pfid (ON, only for E1F)
# 9:  Q2_var_binw_bng (ON)
# 10: t2 (OFF)
# 11: MM2_cut_EI (OFF)
# 12: reconcile (OFF)
# 13: gpart_pid (OFF)
# 14: hitSC_pid (ON)
# 15: stat_pid (OFF)
# 16: thesis Q2W (ON)
# ----

'''
+ h10->Observables labelled by 'obs_jobtag', where jobtag='%s_%s_%s_%s'%(cutsncors,adtnl_opts,IDTFR,DATE) applicable to {ER,SR}. {ST}h10->d2pi independent of 'jobtag'. Details:
	+ cutsncors,adtnl_opts=CUTNCORS applied to {ER,SR}h10->d2pi
	+ IDTFR,DATE=way for user to tag the result
	+ {ST}h10->d2pi directly made on farm labelled by DATE_ST and is independent of 'jobtag'. 
		+ To use the appropriate d2piT_<date>.root, the DATE_ST(expt,sim) is used.   

+ Usage
	>h10_2_Obs expt<=e1f/e16> Q2min Q2max idtfr cumsiml[=SIMS[expt]] date_of_existing_jobtag[=today's MMDDYY]
	+ idtfr: string used to describe the job; can be entered as ""
	+ cumsiml: output created for every cumsim in cumsiml under obs_jobtag/cumsim
	+ date_of_existing_jobtag: date should be of existing jobtag since the program assumes that obs_jobtag is going to be updated with, as set up currently in the code,for example, addition of a new simulation.
'''
USAGE="h10_2_Obs expt<=e1f/e16> Q2min Q2max idtfr cumsiml[=SIMS[expt]] date_of_existing_jobtag[=today's MMDDYY]"

EXPTS=['e1f','e16']
SEQS=['ER','SR','ST']
SIMS={'e1f':['TBD'],'e16':['sim4','sim5','sim6','sim7','sim8','sim9']}
#print EXPTS,SEQS,SIMS

H10PATH='/home/trivedia/ongoing/h10lsts_local'
H10LSTS={
('e1f','ER'):'TBD',
('e16','ER'):'%s/e16/exp/h10-skim-e_010816.lst'%(H10PATH), #! h10-skim-e_122115.lst w/o ER:SF fix
('e1f','SR','sim-TBD'):'TBD',
('e16','SR','sim4'):'%s/e16/sim/sim4/h10-skim-e_122115.lst'%(H10PATH),
('e16','SR','sim5'):'%s/e16/sim/sim5/h10-skim-e_122115.lst'%(H10PATH),
('e16','SR','sim6'):'%s/e16/sim/sim6/h10-skim-e_122915.lst'%(H10PATH),
('e16','SR','sim7'):'%s/e16/sim/sim7/h10-skim-e_010816.lst'%(H10PATH),
('e16','SR','sim8'):'%s/e16/sim/sim8/h10-skim-e_012416.lst'%(H10PATH),
('e16','SR','sim9'):'%s/e16/sim/sim9/h10-skim-e_012416.lst'%(H10PATH)
}
#print H10LSTS
DATE_ST={
('e1f','sim-TBD'):'TBD',
('e16','sim4'):'122215',
('e16','sim5'):'122215',
('e16','sim6'):'122915',
('e16','sim7'):'010816',
('e16','sim8'):'012416',
('e16','sim9'):'012416'
}

#! The two sets of cutncors that I am currently applying and that in the commented out parts below, I am systematically testing for their respective effects on the cross section
CUTSNCORS=OrderedDict()
#CUTSNCORS[('dflt','dflt')]=['eid:efid:pid:pfid:pcorr:evtsel_2pi:',':11:']
#CUTSNCORS[('dflt_eff_scpd',':11:1:2:3:13:14:15:')]=['eid:efid:pid:pfid:pcorr:eff:scpd:evtsel_2pi:',':11:1:2:3:13:14:15:']

#! ##################
#! Systematic study 1
#! Observe affect of each additional cutsncor on top of 'dflt_dflt' that together give 'cuts-EI'. Generally it is observed that:
#! + Q2=[2.0,2.4]: EI-cuts>dflt 
#! + Q2=[2.4,3.0]: EI-cuts`=dflt

#! Results (for full details see handwritten notes):
#! It was found that some of the additional cutsncors increase the cross-section, while some reduce it, while other not 
#! below have no effect:
#! + cutsncors that increase xsec:
#! 			Q2=[2.0,2.4]	Q2=[2.4,3.0]
#! i.   eff_scpd	V		V(slight effect)			
#! ii.  ECfid-on	V		X
#! iii. stat-PID-on	V		V
#! + cutsncors that decrease xsec: 
#! 			Q2=[2.0,2.4]	Q2=[2.4,3.0]
#! i. gpart-PID-on	V		V
#! ##################
CUTSNCORS[('dflt_eff_scpd','dflt')]=['eid:efid:pid:pfid:pcorr:eff:scpd:evtsel_2pi:',':11:']
CUTSNCORS[('dflt','dflt_ECin-on')]=['eid:efid:pid:pfid:pcorr:evtsel_2pi:',':11:1:']
CUTSNCORS[('dflt','dflt_ECfid-on')]=['eid:efid:pid:pfid:pcorr:evtsel_2pi:',':11:2:']
CUTSNCORS[('dflt','dflt_zvtx-on')]=['eid:efid:pid:pfid:pcorr:evtsel_2pi:',':11:3:']
CUTSNCORS[('dflt','dflt_gpart-PID-on')]=['eid:efid:pid:pfid:pcorr:evtsel_2pi:',':11:13:']
CUTSNCORS[('dflt','dflt_hitSC-PID-off')]=['eid:efid:pid:pfid:pcorr:evtsel_2pi:',':11:14:']
CUTSNCORS[('dflt','dflt_stat-PID-on')]=['eid:efid:pid:pfid:pcorr:evtsel_2pi:',':11:15:']

#! ##################
#! [01-24-16] Systemtatic study 2
#! In this study the goal is to further investigate the results of study-1 to answer questions like:
#! + What cutsncors are responsible for the ultimate systematic effect in each Q2 bin, noted in study 1? 
#!    + For example, does the increase caused by one cutncor cancel with the decrease caused by another?
#!    + A hypothesis tested below is that any total increase in cross-section is caused by 'eff_scpd' and
#!      the increase caused by 'stat-PID-on' in cancelled by the decrease caused by 'gpart-PID-on'

#! Results (for full details see handwritten notes):
#! The hypothesis under test i.e. that any total increase in cross-section is caused by 'eff_scpd' and 
#! the increase caused by 'stat-PID-on' in cancelled by the decrease caused by 'gpart-PID-on' was found to be true:
#! + eff_scpd    + ECfid-on     => + : total increase
#! + stat-PID-on - gpart-PID-on => 0 : No net effect
#!   
#! ################## 

#! + cutsncors that increase xsec 
#CUTSNCORS[('dflt_eff_scpd','dflt_ECfid-on-stat-PID-on')]=['eid:efid:pid:pfid:pcorr:eff:scpd:evtsel_2pi:',':11:2:15:']
#! + what does the decrease caused by gpart counter-act?
#! 1. dflt_eff_scpd?
CUTSNCORS[('dflt_eff_scpd','dflt_gpart-PID-on')]=['eid:efid:pid:pfid:pcorr:eff:scpd:evtsel_2pi:',':11:13:']
#! 2. ECfid?
CUTSNCORS[('dflt','dflt_ECfid-on-gpart-PID-on')]=['eid:efid:pid:pfid:pcorr:evtsel_2pi:',':11:2:13:']
#! 3. stat-PID? (Hypothesis)
CUTSNCORS[('dflt','dflt_stat-PID-on-gpart-PID-on')]=['eid:efid:pid:pfid:pcorr:evtsel_2pi:',':11:13:15:']
#! If 1. is correct, then total increase should be due to ECfid-on,stat-PID-on
CUTSNCORS[('dflt','dflt_ECfid-on-stat-PID-on')]=['eid:efid:pid:pfid:pcorr:evtsel_2pi:',':11:2:15:']
#! If 2. is correct, then total increase should be due to eff_scpd,stat-PID-on
CUTSNCORS[('dflt_eff_scpd','dflt_stat-PID-on')]=['eid:efid:pid:pfid:pcorr:eff:scpd:evtsel_2pi:',':11:15:']
#! If 3. (Hypothesis) is correct, then total increase should be due to eff_scpd,ECfid-on and that too only for Q2=[2.0,2.4]
CUTSNCORS[('dflt_eff_scpd','dflt_ECfid-on')]=['eid:efid:pid:pfid:pcorr:eff:scpd:evtsel_2pi:',':11:2:']


if len(sys.argv)<2:
	sys.exit("Please enter expt as per usage: %s"%USAGE)
expt=sys.argv[1]

Q2MIN=""
if len(sys.argv)>2:#i.e. Q2MIN entered by user
        Q2MIN=sys.argv[2]
else:
	sys.exit("Please enter Q2MIN as per usage: %s"%USAGE)

Q2MAX=""
if len(sys.argv)>3:#i.e. Q2MAX entered by user
        Q2MAX=sys.argv[3]
else:
        sys.exit("Please enter Q2MAX as per usage: %s"%USAGE)

IDTFR=""
if len(sys.argv)>4:#i.e. IDTFR entered by user
	IDTFR=sys.argv[4]
else:
	sys.exit("Please enter IDTFR as per usage: %s"%USAGE)

CUMSIML=[]
if len(sys.argv)>5:#i.e. CUMSIML entered by user
	cumsims=sys.argv[5].split("_")
	if len(cumsims)>0:
		for cumsim in cumsims:
			cumsim=cumsim.split(':')
			#print cumsim
			#cumsim=map(int,cumsim)
			for sim_user in cumsim:
				sim_user_valid=False
				for sim in SIMS[expt]:
					#print "sim_user=",sim_user
					#print "sim=",sim
					if sim_user==sim:
						sim_user_valid=True
				if not sim_user_valid:
					sys.exit("Please enter valid simX. %s for %s is not valid."%(sim_user,expt))
			CUMSIML.append(cumsim)
	else:
		sys.exit("Please enter cumsiml as sim1_sim1:sim2_sim1:sim2:sim3")
else:
	CUMSIML.append(SIMS[expt])

PROC_NEW_JOBTAG=True
if len(sys.argv)>6: #! i.e. date of existing jobtag entered by user i.e. update existing jobtag
	DATE=sys.argv[6]
        PROC_NEW_JOBTAG=False
else:
        DATE=datetime.datetime.now().strftime('%m%d%y')

print "expt=",expt
print "Q2MIN=",Q2MIN
print "Q2MAX=",Q2MAX
print "IDTFR=",IDTFR
print "DATE=",DATE
print "PROC_NEW_JOBTAG=",PROC_NEW_JOBTAG
print "CUMSIML=",CUMSIML
#sys.exit()

for k in CUTSNCORS.keys():
	cutsncors,adtnl_opts= k[0],k[1]
    	cutsncors_code,adtnl_opts_code= CUTSNCORS[k][0],CUTSNCORS[k][1]
	#! For SR, remove ':pcorr' from cutsncor_code
	cutsncors_code_SR=cutsncors_code.replace(':pcorr','')
	jobtag='%s_%s_%s_%s'%(cutsncors,adtnl_opts,IDTFR,DATE)
	print "h10->Obs for jobtag=%s"%jobtag
	print "h10->Obs for expt:cutsncors:adtnl_opts=(%s:%s:%s)"%(expt,cutsncors,adtnl_opts)
	print "h10->Obs for expt:cutsncors_code:cutsncors_code_SR:adtnl_opts_code=(%s:%s:%s:%s)"%(expt,cutsncors_code,cutsncors_code_SR,adtnl_opts_code)

	logdir=""
	if PROC_NEW_JOBTAG:
		logdir="/home/trivedia/h10_2_Obs_logs/%s"%jobtag
	else:
		logdir="/home/trivedia/h10_2_Obs_logs/%s_update_%s"%(jobtag,datetime.datetime.now().strftime('%m%d%y_%H%M%S'))
	if not os.path.exists(logdir):
		os.makedirs(logdir)
	#! + While I can re-direct stdout/err of all subprocesses to logdir/<log> using Popen,
	#!   I have to use a hack-ish method to redirect stdout (mainly from print messages)
	#!   from the main program to logdir/main.log
	#! + Using this method, the main.log is not updated in real-time but after the file is
	#!   closed at the end of the program! Therefore, 'print' continue to accompany 'mainlog.write'
	#!   to see real-time progress
	mainlog=open("%s/main.log"%(logdir),'w')
	print "All stdout from h10_2_Obs are in %s/%s"%(logdir,"main.log")

	print "h10->Obs for expt:cutsncors:adtnl_opts=(%s:%s:%s)"%(expt,cutsncors,adtnl_opts)
        print "h10->Obs for expt:cutsncors_code:adtnl_opts_code=(%s:%s:%s)"%(expt,cutsncors_code,adtnl_opts_code)
	mainlog.write("h10->Obs for expt:cutsncors:adtnl_opts=(%s:%s:%s)\n"%(expt,cutsncors,adtnl_opts))
	mainlog.write("h10->Obs for expt:cutsncors_code:adtnl_opts_code=(%s:%s:%s)\n"%(expt,cutsncors_code,adtnl_opts_code))
		
	#! 1. {ER,SR,ST}:{h10-skim-e->d2pi,h10->d2pi}
	print "*** 1. {ER,SR,ST}:{h10-skim-e->d2pi,h10->d2pi} ***"
	mainlog.write("*** 1. {ER,SR,ST}:{h10-skim-e->d2pi,h10->d2pi} ***\n")
	#! ER
	print "*** ER *** "
	mainlog.write("*** ER ***\n")
	sfx=''
	if expt=='e16':sfx='_E16'
	d2pidir_exp=os.path.join(os.environ['D2PIDIR_EXP%s'%sfx],jobtag)
	print 'd2pidir_exp=',d2pidir_exp
	mainlog.write('d2pidir_exp=%s\n'%d2pidir_exp)
	if not os.path.exists(d2pidir_exp):
		os.makedirs(d2pidir_exp)
	#! Process d2piR.root only if it does not exist OR if processing a non-existing jobtag 
        if not os.path.isfile(os.path.join(d2pidir_exp,"d2piR.root")) or PROC_NEW_JOBTAG:
		h10lst=H10LSTS[expt,'ER']
		print 'h10lst=',h10lst
		mainlog.write('h10lst=%s\n'%h10lst)
		cmd=["proc_h10_lite","-i","%s"%h10lst,"-t","%s:exp:2pi:recon"%expt,"-c","%s"%cutsncors_code, "-o","%s/d2piR.root"%d2pidir_exp, "%s"%adtnl_opts_code]
		#! For debug
		#cmd=["proc_h10_lite","-i","%s"%h10lst,"-t","%s:exp:2pi:recon"%expt,"-c","%s"%cutsncors_code, "-o","%s/d2piR.root"%d2pidir_exp, "-n","10000","%s"%adtnl_opts_code]
        	print">>>%s >& %s/h10_2_d2pi_ER.log.log\n"%(cmd,logdir)
		mainlog.write(">>>%s >& %s/h10_2_d2pi_ER.log.log\n"%(cmd,logdir))
		logfile=open('%s/h10_2_d2pi_ER.log'%logdir,'w')
		#! + Popen called below without keeping any references to the Popen objects
		#!   (http://stackoverflow.com/questions/2760652/how-to-kill-or-avoid-zombie-processes-with-subprocess-module: ibz answered Aug 15 '11 at 9:53)
		#! + This way no zombie child processes are left and this is important
		#!   for the manner in which I am tracking and noting the completion of
		#!   ER,SR{sims}}:h10->d2pi processes below
		subprocess.Popen(cmd,stdout=logfile,stderr=subprocess.STDOUT)
	else:
		print os.path.join(d2pidir_exp,"d2piR.root"),"exists. Not making new one"
                mainlog.write("%s exists. Not making new one\n"%os.path.join(d2pidir_exp,"d2piR.root"))	

	#! SR
	print "SR"
	mainlog.write("SR\n")
	for CUMSIM in CUMSIML:
		print "*** SR for CUMSIM=%s***"%CUMSIM
		mainlog.write("*** SR for CUMSIM=%s ****\n"%CUMSIM)
		for i,sim in enumerate(CUMSIM): #enumerate(SIMS[expt]):
			sfx=''
        		if expt=='e16':sfx='_E16'
        		d2pidir_sim=os.path.join(os.environ['D2PIDIR_SIM%s'%sfx],sim,jobtag)
			if not os.path.exists(d2pidir_sim):
                		os.makedirs(d2pidir_sim)
			#! Process d2piR.root only if it does not exist OR if processing a non-existing jobtag 
			if not os.path.isfile(os.path.join(d2pidir_sim,"d2piR.root")) or PROC_NEW_JOBTAG:
				h10lst=H10LSTS[expt,'SR',sim] 
				print 'sim=',sim
				mainlog.write('sim=%s\n'%sim)
				print 'h10lst=',h10lst
				print 'd2pidir_sim=',d2pidir_sim
				mainlog.write('h10lst=%s\n'%h10lst)
				mainlog.write('d2pidir_sim=%s\n'%d2pidir_sim)
				cmd=["proc_h10_lite","-i", "%s"%h10lst,"-t","%s:sim:2pi:recon"%expt,"-c","%s"%cutsncors_code_SR, "-o","%s/d2piR.root"%d2pidir_sim, "%s"%adtnl_opts_code]
				#! For debug
				#cmd=["proc_h10_lite","-i", "%s"%h10lst,"-t","%s:sim:2pi:recon"%expt,"-c","%s"%cutsncors_code_SR, "-o","%s/d2piR.root"%d2pidir_sim, "-n","10000","%s"%adtnl_opts_code]
				print">>>%s >& %s/h10_2_d2pi_SR_%s.log.log\n"%(cmd,logdir,sim)
				mainlog.write(">>>%s >& %s/h10_2_d2pi_SR_%s.log.log\n"%(cmd,logdir,sim))
				logfile=open('%s/h10_2_d2pi_SR_%s.log'%(logdir,sim),'w')
				#! + Popen called below without keeping any references to the Popen objects
        			#!   (http://stackoverflow.com/questions/2760652/how-to-kill-or-avoid-zombie-processes-with-subprocess-module: ibz answered Aug 15 '11 at 9:53)
        			#! + This way no zombie child processes are left and this is important
        			#!   for the manner in which I am tracking and noting the completion of
        			#!   ER,SR{sims}}:h10->d2pi processes below
				subprocess.Popen(cmd,stdout=logfile,stderr=subprocess.STDOUT)
			else:
				print os.path.join(d2pidir_sim,"d2piR.root"),"exists. Not making new one"
				mainlog.write("%s exists. Not making new one\n"%os.path.join(d2pidir_sim,"d2piR.root"))

			#! ST
			#! + For each sim,should directly already have been made on the farm on DATE_ST

	#! Wait for h10->d2pi for ER,SR{sims} to finish before proceeding
	while True:
		#! Following command taken from $HOME/ongoing/bin/track_mem_dR2
		process=subprocess.Popen("ps aux | grep \"[p]roc_h10_lite\" | awk '{print $4}'",shell=True,stdout=subprocess.PIPE)
		out,err=process.communicate()
		#print out
		if out=="":
			break
		else:
			print "proc_h10_lite(s) still running"
			mainlog.write("proc_h10_lite(s) still running\n")
			crnt_time=datetime.datetime.now().strftime('%H:%M:%S')
			print "%MEM usage (checked every 5min) of each running instance at",crnt_time,"(HH:MM:SS):"
			mainlog.write("MEM percentage usage (checked every 15min) of each running instance at %s(HH:MM:SS)\n"%crnt_time)
			print out
			mainlog.write("%s\n"%out)
			time.sleep(5*60)
			#! For debug
			#time.sleep(60)

		
	#! Add d2piR/T from sims
	#! NOTE:
	#! + d2pidir_SR_total is dependent on jobgtag and therefore on CUTSNCORS applied to {ER,SR}h10->d2pi
	#! 	+ d2pidir_SR_total=$D2PIDIR_SIM(_E16)/cumsim/jobtag
	#! + d2pidir_ST_total is *independent* of jobgtag and {ST}h10->d2pi is directly made on farm and labelled by dates in DATE_ST
	#! 	+ d2pidir_ST_total=$D2PIDIR_SIM(_E16)/cumsim/T_cumsim1-<DATE_ST(expt,cumsim1)>_cumsim2-<DATE_ST(expt,cumsim2)>_cumsimX-<DATE_ST(expt,cumsimX)>
	for CUMSIM in CUMSIML:
		print "*** hadd d2piR.root, d2piT.root for cumsim=%s"%CUMSIM
		mainlog.write("*** hadd d2piR.root, d2piT.root for cumsim=%s ***\n"%CUMSIM)
		sim_total="_".join(CUMSIM) #"_".join(SIMS[expt])
		sfx=''
		if expt=='e16':sfx='_E16'
		#! d2pidir_SR_total
		d2pidir_SR_total=os.path.join(os.environ['D2PIDIR_SIM%s'%sfx],sim_total,jobtag)
		#! d2pidir_ST_total
		d2pidir_ST_total=os.path.join(os.environ['D2PIDIR_SIM%s'%sfx],sim_total,'T')
		d2pidir_ST_total_sfx=''
		for i,sim in enumerate(CUMSIM):#enumerate(SIMS[expt]):
    			#print sim,DATE_ST[expt,sim]
    			d2pidir_ST_total_sfx+='_%s-%s'%(sim,DATE_ST[expt,sim])	
		d2pidir_ST_total+=d2pidir_ST_total_sfx
		#! create d2pidir_SR(ST)_total
		for drctry in [d2pidir_SR_total,d2pidir_ST_total]:
			if not os.path.exists(drctry):
				os.makedirs(drctry)	
		tgtfl=['d2piR.root','d2piT.root']
		for f in tgtfl:
			#! First determine if adding d2piR or d2piT
			addSR,addST=False,False
			logfilename=""
			if   "R" in f: 
				addSR=True
				hadd_outdir=d2pidir_SR_total
				logfilename="hadd_SR_sim_%s.log"%(sim_total)
			elif "T" in f: 
				addST=True
				hadd_outdir=d2pidir_ST_total
				logfilename="hadd_ST_sim_%s.log"%(sim_total)
			#! Now hadd
			if ( (addSR and len(CUMSIM)>1) and (not os.path.isfile(os.path.join(hadd_outdir,f)) or PROC_NEW_JOBTAG) ) or (addST and not  os.path.isfile(os.path.join(hadd_outdir,f))):
				logfile=open('%s/%s'%(logdir,logfilename),'w')
				tgtf=os.path.join(hadd_outdir,f)
 				srcfl=[]
    				for sim in (CUMSIM):#(SIMS[expt]):
					if addSR:
						srcfl.append(os.path.join(os.environ['D2PIDIR_SIM%s'%sfx],sim,jobtag,'d2piR.root'))
					elif addST:
						srcfl.append(os.path.join(os.environ['D2PIDIR_SIM%s'%sfx],sim,'d2piT_%s.root'%DATE_ST[expt,sim]))
    				srcfl=sorted(srcfl)
    				cmd=["hadd","-f",tgtf] #! hadd with -f since I often have to remake the same tgtf
    				cmd+=srcfl
                		print">>>%s >& %s/%s\n"%(cmd,logdir,logfilename)
				mainlog.write(">>>%s >& %s/%s\n"%(cmd,logdir,logfilename))
				tool=subprocess.Popen(cmd,stdout=logfile,stderr=subprocess.STDOUT)
				tool.wait()
			else:
				if addSR and len(CUMSIM)==1:
					print "Not going to hadd since len(CUMSIM)==1 and therefore already %s/%s exists"%(hadd_outdir,f)
                                	mainlog.write("Not going to hadd since len(CUMSIM)==1 and therefore %s/%s exists\n"%(hadd_outdir,f))
				else:
					print "Not going to hadd since %s/%s exists"%(hadd_outdir,f)
                               		mainlog.write("Not going to hadd since %s/%s exists\n"%(hadd_outdir,f))

		#! 2. d2pi->Observables
		print "*** 2. d2pi->Observables for %s***"%CUMSIM
		mainlog.write("*** 2. d2pi->Observables for %s ***\n"%CUMSIM)
		#! Create and prepare obsdir
		#logfile=open("%s/prep_obsdir_%s.log"%(logdir,sim_total),'w')
		sfx=''
		if expt=='e16':sfx='_E16'
		obsdir=os.path.join(os.environ['OBSDIR%s'%sfx],'obs_%s'%jobtag)
		print "obsdir=",obsdir
		mainlog.write("obsdir=%s\n"%obsdir)
		if not os.path.exists(obsdir):
			os.makedirs(obsdir)
		if not os.path.exists(os.path.join(obsdir,'d2pi_exp')):
			os.makedirs(os.path.join(obsdir,'d2pi_exp'))
		if not os.path.exists(os.path.join(obsdir,'d2pi_sim',sim_total)):
			os.makedirs(os.path.join(obsdir,'d2pi_sim',sim_total))

		#! Link files into obsdir/d2pi_exp(_sim)
		if not os.path.isfile(os.path.join(obsdir,"d2pi_exp/d2piR.root")) or PROC_NEW_JOBTAG:
			logfile=open("%s/prep_obsdir_%s.log"%(logdir,sim_total),'a')
			#! First unlink any existing link
			cmd=["unlink","%s/d2pi_exp/d2piR.root"%(obsdir)]
			print">>>%s\n"%cmd
                        mainlog.write(">>>%s\n"%cmd)
                        subprocess.Popen(cmd,stdout=logfile,stderr=subprocess.STDOUT)
			#! Recreate link
			cmd=["ln", "-s", "%s/d2piR.root"%d2pidir_exp,"%s/d2pi_exp/d2piR.root"%(obsdir)]
			print">>>%s\n"%cmd
			mainlog.write(">>>%s\n"%cmd)
			subprocess.Popen(cmd,stdout=logfile,stderr=subprocess.STDOUT)
		else:
			print os.path.join(obsdir,"d2pi_exp/d2piR.root"),"exists. Not making new one"
			mainlog.write("%s exists. Not making new one\n"%os.path.join(obsdir,"d2pi_exp/d2piR.root"))
	
		if not os.path.isfile(os.path.join(obsdir,"d2pi_sim",sim_total,"d2piR.root")) or PROC_NEW_JOBTAG:
			logfile=open("%s/prep_obsdir_%s.log"%(logdir,sim_total),'a')
			#! First unlink any existing link
			cmd=["unlink","%s/d2pi_sim/%s/d2piR.root"%(obsdir,sim_total)]
                        print">>>%s\n"%cmd
                        mainlog.write(">>>%s\n"%cmd)
                        subprocess.Popen(cmd,stdout=logfile,stderr=subprocess.STDOUT)
			#! Recreate link
			cmd=(["ln", "-s", "%s/d2piR.root"%d2pidir_SR_total,"%s/d2pi_sim/%s/d2piR.root"%(obsdir,sim_total)])
			print">>>%s\n"%cmd
			mainlog.write(">>>%s\n"%cmd)
			subprocess.Popen(cmd,stdout=logfile,stderr=subprocess.STDOUT)
		else:
			print os.path.join(obsdir,"d2pi_sim",sim_total,"d2piR.root"),"exists. Not making new one"
			mainlog.write("%s exists. Not making new one\n"%os.path.join(obsdir,"d2pi_sim",sim_total,"d2piR.root"))

		if not os.path.isfile(os.path.join(obsdir,"d2pi_sim",sim_total,"d2piT.root")) or PROC_NEW_JOBTAG:
			logfile=open("%s/prep_obsdir_%s.log"%(logdir,sim_total),'a')
			#! First unlink any existing link
                        cmd=["unlink","%s/d2pi_sim/%s/d2piT.root"%(obsdir,sim_total)]
                        print">>>%s\n"%cmd
                        mainlog.write(">>>%s\n"%cmd)
                        subprocess.Popen(cmd,stdout=logfile,stderr=subprocess.STDOUT)
                        #! Recreate link
			cmd=(["ln", "-s", "%s/d2piT.root"%(d2pidir_ST_total),"%s/d2pi_sim/%s/d2piT.root"%(obsdir,sim_total)])
			print">>>%s\n"%cmd
			mainlog.write(">>>%s\n"%cmd)
			subprocess.Popen(cmd,stdout=logfile,stderr=subprocess.STDOUT)
		else:
			print os.path.join(obsdir,"d2pi_sim",sim_total,"d2piT.root"),"exists. Not making new one"
			mainlog.write("%s exists. Not making new one\n"%os.path.join(obsdir,"d2pi_sim",sim_total,"d2piT.root"))

		#-- Now start to make Obervables
		#echo ">ph8 $obsdir $sim 2.00 3.00 1.400 2.125 >& $logdir_obs/ph8.log "
		if not os.path.isfile(os.path.join(obsdir,sim_total,"yield.root")) or PROC_NEW_JOBTAG:
			cmd=["ph8",obsdir,sim_total,Q2MIN,Q2MAX,'1.400','2.125']
			logfile=open("%s/ph8_%s.log"%(logdir,sim_total),'w')
			print">>>%s >& %s/ph8_%s.log\n"%(cmd,logdir,sim_total)
			mainlog.write(">>>%s >& %s/ph8_%s.log\n"%(cmd,logdir,sim_total))
			tool=subprocess.Popen(cmd,stdout=logfile,stderr=subprocess.STDOUT)
			tool.wait();
		else:
			print os.path.join(obsdir,sim_total,"yield.root"),"exists. Not making new one"
                	mainlog.write("%s exists. Not making new one\n"%os.path.join(obsdir,sim_total,"yield.root")) 

		#echo ">dobs_1D $obsdir $sim norm 2.00 3.00 1.400 2.125 >& $logdir_obs/dobs_1D.log"
		if not os.path.exists(os.path.join(obsdir,sim_total,"Obs_1D_norm")) or PROC_NEW_JOBTAG:
			cmd=["dobs_1D",obsdir,sim_total,"norm",Q2MIN,Q2MAX,'1.400','2.125',expt]
			logfile=open("%s/dobs_1D_%s.log"%(logdir,sim_total),'w')
			print">>>%s >& %s/dobs_1D_%s.log\n"%(cmd,logdir,sim_total)
			mainlog.write(">>>%s >& %s/dobs_1D_%s.log\n"%(cmd,logdir,sim_total))
        		tool=subprocess.Popen(cmd,stdout=logfile,stderr=subprocess.STDOUT)
			tool.wait()
		else:
			print os.path.join(obsdir,sim_total,"Obs_1D_norm"),"exists. Not making new one"
                        mainlog.write("%s exists. Not making new one\n"%os.path.join(obsdir,sim_total,"Obs_1D_norm"))

		#-- simstats
		#echo ">ds_lite $obsdir sim1 >& $logdir_obs/ds_lite.log"
		if not os.path.isfile(os.path.join(obsdir,sim_total,"simstats/simstats.root")) or PROC_NEW_JOBTAG:
			cmd=['ds_lite',obsdir,sim_total]
			logfile=open('%s/ds_lite_%s.log'%(logdir,sim_total),'w')
			print">>>%s >& %s/ds_lite_%s.log\n"%(cmd,logdir,sim_total)
			mainlog.write(">>>%s >& %s/ds_lite_%s.log\n"%(cmd,logdir,sim_total))
        		tool=subprocess.Popen(cmd,stdout=logfile,stderr=subprocess.STDOUT)
			tool.wait()
		else:
			print os.path.join(obsdir,sim_total,"simstats/simstats.root"),"exists. Not making new one"
                        mainlog.write("%s exists. Not making new one\n"%os.path.join(obsdir,sim_total,"simstats/simstats.root"))

		#echo "ds_q2wbin_lite $obsdir sim1 >& $logdir_obs/ds_q2wbin_lite.log"
		if not os.path.isfile(os.path.join(obsdir,sim_total,"simstats/simstats_q2wbin.root")) or PROC_NEW_JOBTAG:
			cmd=['ds_q2wbin_lite',obsdir,sim_total]
			logfile=open('%s/ds_q2wbin_lite_%s.log'%(logdir,sim_total),'w')
			print">>>%s >& %s/ds_q2wbin_lite_%s.log\n"%(cmd,logdir,sim_total)
			mainlog.write(">>>%s >& %s/ds_q2wbin_lite_%s.log\n"%(cmd,logdir,sim_total))
        		tool=subprocess.Popen(cmd,stdout=logfile,stderr=subprocess.STDOUT)
			tool.wait()
		else:
			print os.path.join(obsdir,sim_total,"simstats/simstats.root"),"exists. Not making new one"
                        mainlog.write("%s exists. Not making new one\n"%os.path.join(obsdir,sim_total,"simstats/simstats_q2wbin.root"))

	mainlog.close()
